#+PROPERTY: header-args:clojure+ :results silent
#+PROPERTY: header-args:clojure :exports both
#+PROPERTY: header-args:clojure+ :session lumen
#+PROPERTY: header-args:clojure+ :padline yes
#+PROPERTY: header-args:clojure+ :mkdirp yes
#+PROPERTY: header-args:clojure+ :tangle ../src/akvo/lumen/specs/visualisation.clj
#+FILETAGS: :visualisation:
* glossary
  raster graphics https://en.wikipedia.org/wiki/Raster_graphics#Etymology
 
* lib.visualisation contents

Examining visualisation folder ... LOC & path

#+BEGIN_SRC shell :exports results
wc -l `find ../src/akvo/lumen/lib/visualisation -type f`
echo " ... | ..."
wc -l ../src/akvo/lumen/lib/visualisation.clj
#+END_SRC      

#+RESULTS:
| 373 | ../src/akvo/lumen/lib/visualisation/map_config.clj   |   |     |
| 178 | ../src/akvo/lumen/lib/visualisation/map_metadata.clj |   |     |
| 120 | ../src/akvo/lumen/lib/visualisation/maps.clj         |   |     |
| 671 | total                                                |   |     |
| ... |                                                      |   | ... |
|  54 | ../src/akvo/lumen/lib/visualisation.clj              |   |     |


... we have a main ns ~lib.visualisation~ that just dispatch to maps (with config && metadata in mind)


* visualisation layer legend
#+BEGIN_SRC clojure :tangle ../src/akvo/lumen/specs/visualisation/layer/legend.clj :exports code
(ns akvo.lumen.specs.visualisation.layer.legend
  (:require
	    [akvo.lumen.specs.core :as lumen.s]
	    [akvo.lumen.specs.libs]
	    [clojure.spec.alpha :as s]))

(s/def ::title (s/or :v string? :n nil?))
(s/def ::visible boolean?)

(s/def ::legend (s/keys :req-un [::title ::visible]))

#+END_SRC

* visualisation layer spec
#+BEGIN_SRC clojure :tangle ../src/akvo/lumen/specs/visualisation/layer/spec.clj :exports code
(ns akvo.lumen.specs.visualisation.layer.spec
  (:require
   [akvo.lumen.specs.core :as lumen.s]
   [akvo.lumen.specs.visualisation.layer :as visualisation.layer.s]
   [akvo.lumen.specs.libs]
   [clojure.spec.alpha :as s]))

(s/def ::version int?)
(s/def ::baseLayer #{"terrain" "satellite" "street"})
(s/def ::layers (s/coll-of ::visualisation.layer.s/layer :gen-max 3))

(s/def ::spec (s/keys :req-un [::layers
			       ::version
			       ::baseLayer]))


#+END_SRC

* visualisation layer
#+BEGIN_SRC clojure :tangle ../src/akvo/lumen/specs/visualisation/layer.clj :exports code
(ns akvo.lumen.specs.visualisation.layer
  (:require [akvo.lumen.component.tenant-manager :as tenant-manager]
	    [akvo.lumen.lib :as lib]
	    [akvo.lumen.lib.visualisation :as lib.visualisation]
            [akvo.lumen.lib.visualisation.map-config :as l.visualisation.map-config]
            [akvo.lumen.lib.visualisation.map-metadata :as l.visualisation.map-metadata]
	    [akvo.lumen.specs.core :as lumen.s]
	    [akvo.lumen.specs.dataset :as dataset.s]
	    [akvo.lumen.specs.dataset.column :as dataset.column.s]
            [akvo.lumen.specs.visualisation.layer.legend :as layer.legend.s]
	    [akvo.lumen.specs.db :as db.s]
	    [akvo.lumen.specs.libs]
	    [clojure.spec.alpha :as s]))

(s/def ::aggregationMethod #{"avg"} ) ;; TODO: check with /Users/tangrammer/git/akvo/akvo-lumen/backend/src/akvo/lumen/specs/aggregation/query.clj::21

(s/def ::popup  coll?)
(s/def ::filters coll?)
(s/def ::layerType #{"geo-location" "geo-shape" "raster"})
(s/def ::legend (s/keys :req-un [::layer.legend.s/title ::layer.legend.s/visible])) 

(s/def ::rasterId (s/or :v ::lumen.s/str-uuid
                        :n nil?))
(s/def ::pointSize (s/or :s ::lumen.s/str-int
                         :i int?))
(s/def ::pointColorMapping coll?) 
(s/def ::longitude (s/or :v ::lumen.s/any :n nil?))
(s/def ::latitude (s/or :v ::lumen.s/any :n nil?))
(s/def ::datasetId (s/or :v ::lumen.s/str-uuid :n nil?))

(s/def ::title string?)
(s/def ::geom (s/or :v string? :n nil?))

(s/def ::pointColorColumn (s/or :v ::lumen.s/any :n nil?))
(s/def ::visible boolean?)




(s/def ::layer (s/keys :req-un [::aggregationMethod 
                                ::popup 
                                ::filters 
                                ::layerType 
                                ::legend 
                                ::pointSize 
                                ::pointColorMapping 
                                ::longitude 
                                ::datasetId 
                                ::title 
                                ::geom 
                                ::pointColorColumn 
                                ::latitude 
                                ::visible]
                       :opt-un [::rasterId]))
#+END_SRC


* visualisation ns                                                       :ns:

this [[/Users/tangrammer/git/akvo/akvo-lumen/backend/src/akvo/lumen/lib/visualisation.clj::8][namespace]] only communicates with hugsql, so intended functionality doesn't return any kind of vis but storing into db some kind of vis data


 #+BEGIN_SRC clojure :exports code
 (ns akvo.lumen.specs.visualisation
   (:require [akvo.lumen.lib.visualisation :as lib.visualisation]
	     [akvo.lumen.lib.visualisation.map-config :as l.visualisation.map-config]
	     [akvo.lumen.lib.visualisation.map-metadata :as l.visualisation.map-metadata]
	     [akvo.lumen.specs.core :as lumen.s]
	     [akvo.lumen.specs.dataset :as dataset.s]
	     [akvo.lumen.specs.visualisation.layer :as visualisation.layer.s]
	     [akvo.lumen.specs.visualisation.layer.legend :as layer.legend.s]
	     [akvo.lumen.specs.visualisation.layer.spec :as layer.spec.s]
	     [akvo.lumen.specs.db :as db.s]
	     [clojure.spec.alpha :as s]))

 (s/def ::lib.visualisation/type string?)
 (s/def ::lib.visualisation/name string?)
 (s/def ::lib.visualisation/visualisationType
   #{"map" "pivot table" "bar" "line" "area" "pie" "donut" "scatter"})
 (s/def ::lib.visualisation/datasetId (s/or :v ::dataset.s/id
					    :n nil?))

 (s/def ::lib.visualisation/created ::lumen.s/date-int)
 (s/def ::lib.visualisation/modified ::lumen.s/date-int)
 (s/def ::lib.visualisation/status #{"OK"})
 (s/def ::lib.visualisation/id string?)
 (s/def ::lib.visualisation/body
   (s/keys :req-un [::lib.visualisation/datasetId
		    ::lib.visualisation/name
		    ::lib.visualisation/spec
		    ::lib.visualisation/type
		    ::lib.visualisation/visualisationType]

	   :opt-un [::lib.visualisation/created
		    ::lib.visualisation/modified
		    ::layer.spec.s/spec
		    ::lib.visualisation/status
		    ::lib.visualisation/id]))

 (s/fdef lib.visualisation/all
   :args (s/cat
	  :tenant-conn ::db.s/tenant-connection))

 (s/fdef lib.visualisation/create
   :args (s/cat
	  :tenant-conn ::db.s/tenant-connection
	  :body ::lib.visualisation/body
	  :jwt-claims map?))

 (s/fdef lib.visualisation/upsert
   :args (s/cat
	  :tenant-conn ::db.s/tenant-connection
	  :body ::lib.visualisation/body
	  :jwt-claims map?))

 (s/fdef lib.visualisation/fetch
   :args (s/cat
	  :tenant-conn ::db.s/tenant-connection
	  :id ::lib.visualisation/id))

 (s/fdef lib.visualisation/delete
   :args (s/cat
	  :tenant-conn ::db.s/tenant-connection
	  :id ::lib.visualisation/id))





 #+END_SRC


 
 


 
* data sample

#+INCLUDE: "visualisation/payloads.org" 


* db

  #+BEGIN_SRC sql :exports both :database lumen_tenant_1 :engine postgresql  :dbhost localhost :dbport 5432  :dbuser lumen :dbpassword password
 select * from dashboard
 #+END_SRC

 #+RESULTS:


** dashboard table
  | Table "public.dashboard" |                          |           |          |         |
  |--------------------------+--------------------------+-----------+----------+---------|
  | Column                   | Type                     | Collation | Nullable | Default |
  | id                       | text                     |           | not null |         |
  | title                    | text                     |           | not null |         |
  | spec                     | jsonb                    |           |          |         |
  | created                  | timestamp with time zone |           | not null | now()   |
  | modified                 | timestamp with time zone |           | not null | now()   |


** visualisation table
  | Table "public.visualisation" |                          |           |          |         |
  |------------------------------+--------------------------+-----------+----------+---------|
  | Column                       | Type                     | Collation | Nullable | Default |
  | id                           | text                     |           | not null |         |
  | dataset_id                   | text                     |           |          |         |
  | name                         | text                     |           | not null |         |
  | type                         | text                     |           | not null |         |
  | spec                         | jsonb                    |           | not null |         |
  | author                       | jsonb                    |           |          |         |
  | created                      | timestamp with time zone |           |          | now()   |
  | modified                     | timestamp with time zone |           |          | now()   |




 #+BEGIN_SRC elisp
 cider-eval-last-sexp-and-replace	
 #+END_SRC


* TODO keep working with libs/maps
where layers are spec=> layers
[[/Users/tangrammer/git/akvo/akvo-lumen/backend/src/akvo/lumen/endpoint/visualisation.clj::21][/Users/tangrammer/git/akvo/akvo-lumen/backend/src/akvo/lumen/endpoint/visualisation.clj::21]]
